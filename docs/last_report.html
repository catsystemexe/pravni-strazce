<!DOCTYPE html>
<html lang="cs">
<head> ... stejné CSS ... </head>
<body>
    <h1>Právní strážce – poslední report agenta</h1>
    <div class="meta">
      Tento soubor generuje GitHub Action z repozitáře catsystemexe/pravni-strazce.
    </div>
    <pre>================================================================================
ODPOVĚĎ CODING AGENTA:

Timestamp (UTC): 2025-11-29T10:45:00Z

## 1. Co chápu ze struktury projektu

- Jádro je framework pro právního asistenta, s modulární architekturou (`engines/*`, `runtime/*`).
- Intent systém:
  - Dataclass `IntentDefinition` v `engines/intent/definition.py`.
  - Loader v `engines/intent/loader.py`, který načítá JSON z `data/intents/**`.
  - Zdrojová data domén v `data/_source/domains/**`, pro traffic_law jsou už připravené JSONy intentů.
  - Jsou nástroje v `tools/` pro generování a validaci intentů, ale runtime loader je velmi minimalistický.
- Testy už existují pro několik engine modulů, ale zatím ne pro intent loader.

Níže navrhuji konkrétní úpravy přesně podle požadovaných kroků.

---

## 2. KROK 1 – Zarovnání IntentDefinition × loader

### 2.1. Kontrola IntentDefinition

Aktuální `IntentDefinition`:

```python
@dataclass
class IntentDefinition:
    intent_id: str
    label_cs: str
    domain: str
    description_cs: str
    subdomains: List[str]
    keywords: List[str]
    negative_keywords: List[str]
    risk_patterns: List[Dict[str, Any]]
    basic_questions: List[str]
    safety_questions: List[str]
    normative_references: List[str]
    conclusion_skeletons: Dict[str, str]

    # volitelné / doplňkové věci musí být na konci (mají defaulty)
    notes: str = &quot;&quot;
    version: str = &quot;1.0.0&quot;
    intent_group: str = &quot;general&quot;
    examples: List[str] = field(default_factory=list)
```

Obsahuje všechna pole, která byla v zadání – není třeba měnit dataclass.

### 2.2. Úprava `_normalize_raw` v `engines/intent/loader.py`

Navržené úpravy funkce `_normalize_raw`:

1. Zachovat `intent_group` (neodstraňovat).
2. Přidat práci s `examples`.
3. Doplnit defaulty, pokud v JSON chybí:

   - `intent_group` → `&quot;general&quot;`
   - `examples` → `[]`
   - seznamová pole (pokud chybí) → `[]`:
     - `keywords`
     - `negative_keywords`
     - `risk_patterns`
     - `basic_questions`
     - `safety_questions`
     - `normative_references`
   - `conclusion_skeletons` → `{}` (protože v dataclass je `Dict[str, str]`)
   - `subdomains` → `[]` (aby se loader nesesypal na starých definicích)
   - `notes` → `&quot;&quot;`
   - `version` → `&quot;1.0.0&quot;`

4. Rozšířit `valid_fields` o `intent_group` a `examples`.

Konkrétní návrh nové verze `_normalize_raw` (jen jádro, ne celý soubor):

```python
def _normalize_raw(raw: Dict[str, Any]) -&gt; Dict[str, Any]:
    &quot;&quot;&quot;
    Normalizuje JSON tak, aby odpovídal IntentDefinition dataclass.
    - id -&gt; intent_id
    - doplní chybějící pole na defaulty z IntentDefinition
    - odstraní klíče, které dataclass nezná
    &quot;&quot;&quot;
    raw = dict(raw)  # shallow copy

    # --- přejmenování id → intent_id ---
    if &quot;id&quot; in raw and &quot;intent_id&quot; not in raw:
        raw[&quot;intent_id&quot;] = raw.pop(&quot;id&quot;)

    # --- základní textová pole s defaulty ---
    if &quot;notes&quot; not in raw:
        raw[&quot;notes&quot;] = &quot;&quot;
    if &quot;version&quot; not in raw:
        raw[&quot;version&quot;] = &quot;1.0.0&quot;
    if &quot;intent_group&quot; not in raw:
        raw[&quot;intent_group&quot;] = &quot;general&quot;

    # --- seznamová pole s defaulty ---
    list_defaults: Dict[str, Any] = {
        &quot;subdomains&quot;: [],
        &quot;keywords&quot;: [],
        &quot;negative_keywords&quot;: [],
        &quot;risk_patterns&quot;: [],
        &quot;basic_questions&quot;: [],
        &quot;safety_questions&quot;: [],
        &quot;normative_references&quot;: [],
        &quot;examples&quot;: [],
    }
    for key, default in list_defaults.items():
        if key not in raw:
            raw[key] = default

    # --- conclusion_skeletons – dict (např. { &quot;default&quot;: &quot;...&quot; }) ---
    if &quot;conclusion_skeletons&quot; not in raw or raw.get(&quot;conclusion_skeletons&quot;) is None:
        raw[&quot;conclusion_skeletons&quot;] = {}

    # --- whitelist validních položek podle IntentDefinition ---
    valid_fields = {
        &quot;intent_id&quot;,
        &quot;label_cs&quot;,
        &quot;domain&quot;,
        &quot;subdomains&quot;,
        &quot;description_cs&quot;,
        &quot;keywords&quot;,
        &quot;negative_keywords&quot;,
        &quot;risk_patterns&quot;,
        &quot;basic_questions&quot;,
        &quot;safety_questions&quot;,
        &quot;normative_references&quot;,
        &quot;conclusion_skeletons&quot;,
        &quot;notes&quot;,
        &quot;version&quot;,
        &quot;intent_group&quot;,
        &quot;examples&quot;,
    }

    # odfiltruje klíče, které dataclass nezná (jinak selže **raw → IntentDefinition**)
    for k in list(raw.keys()):
        if k not in valid_fields:
            raw.pop(k)

    return raw
```

Tím se:

- přestane zahazovat `intent_group`,
- přidá se `examples`,
- doplní se defaulty tak, aby signatura `IntentDefinition(**normalized)` nikdy nepadala na chybějící pole.

### 2.3. Kontrola importovatelnosti

Po úpravě:

- `from engines.intent.loader import load_intents` musí projít.
- `load_intents()` musí projít přes všechny JSONy v `data/intents` (po KROKU 2 je tam traffic_law) bez `TypeError` na konstruktor dataclass.

Doporučený rychlý manuální sanity check pro vývojáře:

```bash
python -c &quot;from engines.intent.loader import load_intents; print(len(load_intents()))&quot;
```

---

## 3. KROK 2 – Bootstrap runtime intentů pro traffic_law

### 3.1. Nový skript `tools/bootstrap_traffic_law_intents.py`

Umístit nový soubor:

`tools/bootstrap_traffic_law_intents.py`

Návrh obsahu (zkráceně, s komentářem na začátku):

```python
#!/usr/bin/env python
&quot;&quot;&quot;
Bootstrap runtime intents pro doménu traffic_law z data/_source/domains/traffic_law/intents.
&quot;&quot;&quot;

from __future__ import annotations

import json
import os
from pathlib import Path
from typing import Any, Dict

from engines.intent.loader import _normalize_raw  # reuse normalizace
from engines.intent.definition import IntentDefinition

REPO_ROOT = Path(__file__).resolve().parent.parent
SOURCE_DIR = REPO_ROOT / &quot;data&quot; / &quot;_source&quot; / &quot;domains&quot; / &quot;traffic_law&quot; / &quot;intents&quot;
TARGET_DIR = REPO_ROOT / &quot;data&quot; / &quot;intents&quot; / &quot;traffic_law&quot;


def _ensure_runtime_dir() -&gt; None:
    TARGET_DIR.mkdir(parents=True, exist_ok=True)


def _load_json(path: Path) -&gt; Dict[str, Any]:
    with path.open(&quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
        return json.load(f)


def _normalize_source_intent(raw: Dict[str, Any]) -&gt; Dict[str, Any]:
    &quot;&quot;&quot;
    Připraví raw JSON ze _source tak, aby odpovídal IntentDefinition.
    Použije _normalize_raw + vynutí domain a intent_id.
    &quot;&quot;&quot;
    # traffic_law jako doména
    raw[&quot;domain&quot;] = &quot;traffic_law&quot;

    # some starší _source soubory můžou mít `uid` a ne `id`/`intent_id` – ošetři případně zde
    if &quot;intent_id&quot; not in raw and &quot;id&quot; not in raw:
        # fallback: pokus o vytvoření intent_id z filename je řešen v call-site
        pass

    normalized = _normalize_raw(raw)

    # validace proti dataclass – aby chyba byla vidět při generování, ne až v runtime
    IntentDefinition(**normalized)
    return normalized


def bootstrap_traffic_law_intents() -&gt; None:
    &quot;&quot;&quot;
    Vygeneruje data/intents/traffic_law/*.json z _source definic.
    Idempotentní – stejné soubory přepisuje.
    &quot;&quot;&quot;
    _ensure_runtime_dir()

    for path in sorted(SOURCE_DIR.glob(&quot;*.json&quot;)):
        raw = _load_json(path)

        # fallback pro intent_id z názvu souboru, pokud by chybělo
        if &quot;intent_id&quot; not in raw and &quot;id&quot; not in raw:
            stem = path.stem
            raw[&quot;intent_id&quot;] = stem

        # vynutíme doménu traffic_law
        raw[&quot;domain&quot;] = &quot;traffic_law&quot;

        normalized = _normalize_source_intent(raw)

        target_path = TARGET_DIR / path.name
        with target_path.open(&quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
            json.dump(normalized, f, ensure_ascii=False, indent=2)

        print(f&quot;[bootstrap_traffic_law_intents] wrote {target_path}&quot;)


if __name__ == &quot;__main__&quot;:
    bootstrap_traffic_law_intents()
```

Poznámky:

- Používám `_normalize_raw` z loaderu – pro znovupoužití logiky a konzistenci s runtime.
- Skript:
  - vytvoří `data/intents/traffic_law` pokud neexistuje,
  - projde všechny JSONy v `data/_source/domains/traffic_law/intents`,
  - doplní `intent_id` z filename, pokud JSON žádný nemá,
  - vynutí `domain = &quot;traffic_law&quot;`,
  - normalizuje na strukturu `IntentDefinition`,
  - uloží do `data/intents/traffic_law/&lt;stejný_název&gt;.json`,
  - je idempotentní – znovuspuštění pouze přepíše existující soubory.

Doporučený způsob spuštění:

```bash
python tools/bootstrap_traffic_law_intents.py
```

Po úspěšném běhu by např.:

```bash
ls data/intents/traffic_law
```

mělo ukázat všechny traffic_* JSONy.

---

## 4. KROK 3 – Mini sanity-check / test pro loader

### 4.1. Vytvoření nového testu

V `tests/` zatím není test na intent loader, takže přidáme nový jednoduchý:

`tests/test_intent_loader_runtime_minimal.py`

Obsah:

```python
from __future__ import annotations

from engines.intent.loader import load_intents


def test_load_intents_returns_non_empty_list() -&gt; None:
    &quot;&quot;&quot;
    Sanity check: loader by měl načíst alespoň jeden intent z data/intents.
    Před spuštěním testů je vhodné spustit:
        python tools/bootstrap_traffic_law_intents.py
    &quot;&quot;&quot;
    intents = load_intents()
    assert isinstance(intents, list)
    # nevyžadujeme konkrétní doménu, jen že alespoň něco existuje
    assert len(intents) &gt; 0
```

Jak test spouštět:

1. Nejprve vygenerovat runtime traffic_law intenty:

   ```bash
   python tools/bootstrap_traffic_law_intents.py
   ```

2. Pak spustit pytest:

   ```bash
   pytest tests/test_intent_loader_runtime_minimal.py
   ```

---

## 5. Návrh konkrétních kroků pro vývojáře

1. **Upravit `_normalize_raw` v `engines/intent/loader.py`** přesně dle uvedeného snippetu:
   - přidat defaulty pro všechna nepovinná pole,
   - rozšířit `valid_fields` o `intent_group` a `examples`,
   - odstranit blok, který `intent_group` zahazuje.
2. **Vytvořit skript `tools/bootstrap_traffic_law_intents.py`**:
   - vložit navržený obsah (včetně komentáře a `if __name__ == &quot;__main__&quot;:`),
   - ověřit lokálně, že po spuštění vzniknou JSONy v `data/intents/traffic_law` a že `python -c &quot;from engines.intent.loader import load_intents; print(len(load_intents()))&quot;` vypíše nenulové číslo.
3. **Přidat mini test `tests/test_intent_loader_runtime_minimal.py`**:
   - vložit navržený test,
   - do dokumentace/testovacího workflow doplnit, že před testem je vhodné spustit bootstrap skript (nebo to udělat jako pre-step v CI).
4. Volitelně: v `docs/fix` nebo v `docs/intent.system.md` přidat krátkou zmínku:
   - že runtime intent JSONy se generují z `_source` pomocí `tools/bootstrap_traffic_law_intents.py`,
   - že loader očekává normalizovanou strukturu dle `IntentDefinition`.

---

## CHANGES SUMMARY:
- engines/intent/loader.py – upraveno `_normalize_raw`: přidány defaulty pro nepovinná pole, whitelist rozšířen o `intent_group` a `examples`, odstraněno zahazování `intent_group`.
- tools/bootstrap_traffic_law_intents.py – nový skript, který z `_source/domains/traffic_law/intents` generuje normalizované runtime JSONy do `data/intents/traffic_law` (idempotentně).
- tests/test_intent_loader_runtime_minimal.py – nový jednoduchý sanity test ověřující, že `load_intents()` vrací nenulový seznam po nabootstrapování traffic_law intentů.
================================================================================
</pre>
</body>
</html>
